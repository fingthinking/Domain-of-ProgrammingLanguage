# Introduction

## Overview

**线程与锁**：线程与锁模型有很多众所周知的不足，但仍是其他模型的技术基础，也是很多并发软件开发的首选。

**函数式编程**：函数式编程日渐重要的原因之一，是其对并发编程和并行编程提供了良好的支持。函数式编程消除了可变状态，所以从根本上是线程安全的，而且易于并行执行。

**Clojure 之道——分离标识与状态**：编程语言 Clojure 是一种指令式编程和函数式编程的混搭方案，在两种编程方式上取得了微妙的平衡来发挥两者的优势。

**actor**：actor 模型是一种适用性很广的并发编程模型，适用于共享内存模型和分布式内存模型，也适合解决地理分布型问题，能提供强大的容错性。

**通信顺序进程(Communicating Sequential Processes，CSP)**：表面上看，CSP 模型与 actor 模型很相似，两者都基于消息传递。不过 CSP 模型侧重于传递信息的通道，而 actor 模型侧重于通道两端的实体，使用 CSP 模型的代码会带有明显不同的风格。

**数据级并行**：每个笔记本电脑里都藏着一台超级计算机——GPU。GPU 利用了数据级并行，不仅可以快速进行图像处理，也可以用于更广阔的领域。如果要进行有限元分析、流体力学计算或其他的大量数字计算，GPU 的性能将是不二选择。

**Lambda 架构**：大数据时代的到来离不开并行——现在我们只需要增加计算资源，就能具有处理 TB 级数据的能力。Lambda 架构综合了 MapReduce 和流式处理的特点，是一种可以处理多种大数据问题的架构。

## Reference

- [concurrency-models](http://tutorials.jenkov.com/java-concurrency/concurrency-models.html)
- [七周七并发模型](https://drive.wps.cn/view/l/3db758274cf94555a456332436ec5f19)
- [并发之痛 Thread，Goroutine，Actor](http://www.tuicool.com/articles/MNVbAbQ)

# Actor

Smalltalk 的设计者、面向对象编程之父 Alan Kay 曾经这样描述面向对象的本质 ①：很久以前，我在描述“面向对象编程”时使用了“对象”这个概念。很抱歉这个概念让许多人误入歧途，他们将学习的重心放在了“对象”这个次要的方面。真正主要的方面是“消息”……日文中有一个词 ma，表示“间隔”，与其最为相近的英文或许是“

interstitial”。创建一个规模宏大且可生长的系统的关键在于其模块之间应该如何交流，而不在于其内部的属性和行为应该如何表现。这段话也概括了使用 actor 模型进行编程的精髓——我们可以认为 actor 模型是面向对象模型在并发编程领域的扩展。

actor 模型精心设计了消息传输和封装的机制，强调了面向对象的精髓，可以说 actor 模型非常“面向对象”。

**优点**

actor 有许多优良的特性，适用于解决多种并发问题。消息传输和封装虽然多个 actor 可以同时运行，但它们并不共享状态，而且在单个 actor 中所有事件都是串行执行的。所以关于并发，只需要关注于多个 actor 之间的消息流即可。

对开发人员来说这是个重大利好。每个 actor 可以被单独测试，而且当测试覆盖了某个 actor 的消息类型和消息顺序时，就可以确定这个 actor 非常可靠。如果发现了一个与并发相关的 bug，也就知道重点应该放在 actor 之间的消息流上。

**容错**

使用 actor 模型的程序天生具有容错性。这不仅会让程序更加强壮，而且(通过“任其崩溃”的哲学)会让代码更加简洁明了。

** 分布式编程**

actor 模型支持共享内存模型，也支持分布式内存模型，这就带来了很多优点。首先， actor 模型几乎可以解决任何规模的问题。我们不需要将问题局限于用一个系统解决。其次， actor 模型可以解决地理分布式问题。对于不同部分需要部署在不同地理位置的软件，Actor 模型是个极佳的选择。最后，分布式是软件具有容错能力的基石。

**缺点**

尽管使用 actor 模型的程序比使用线程与锁模型的程序更容易 debug，但 actor 模型仍会碰到死锁这一类的共性问题，也会碰到一些 actor 模型独有的问题(例如信箱溢出)。

类似于线程与锁模型， actor 模型对并行也没有提供直接支持。需要通过并发的技术来构造并行的方案，这样就会引入不确定性。而且，由于多个 actor 并不共享状态，仅通过消息传递来进行交流，所以不太适合实施细粒度的并行。

**其他语言**

与许多伟大的思想一样， actor 模型也由来悠久——20 世纪 70 年代 Carl Hewitt 首次提出这个模型。 Erlang 无疑为布道 actor 做了最大的贡献。比如 Erlang 的创始人 Joe Armstrong 也是“任其崩溃”哲学的先驱。大部分流行的编程语言都提供了一个 actor 库，特别是 Akka 库 ① 为 Java 和其他运行于 JVM 的语言提供了对 actor 模型的支持。如果想深入学习 Akka，建议阅读本书的奖励章节 ②，其中描述了如何用 Scala 进行 actor 编程。

# Model Comparison

## Benchmark

### [Skynet](https://github.com/atemerev/skynet)

Skynet 用于测试各种语言在生成百万 Actor/Fiber 的开销。大致的逻辑是先生成 10 个 Fiber，每个 Fiber 再生成 10 个 Fiber，直到生成 1 百万个 Fiber，然后每个 Fiber 做加法累积计算，并把结果发 到 channel 里，这样一直递归到根 Fiber。后将最终结果发到 channel。如果逻辑没有错的话结果应该是 499999500000。
| Benchmark(ms) | Macbook 12 | Win 8.1 | Ubuntu 15.10 |
| ------------------------------ | ---------- | --------- | ------------ |
| Actors-Scala/Akka | 6379 | 4419 | 1700-2700 |
| Actors-Erlang(non-HIPE) | 4414 | 1700 | 700-1100 |
| Actors(HIPE) | 3999 | | 2100-3500 |
| Coroutines/Channels-Haskell | 6181 | 2820 | 41-44 |
| Coroutines/Channels-Go | 979 | | 200-224 |
| Coroutines/Channels-F# | | 756 | |
| Futures/Promises-.NET Core | 650 | 290 | |
| Futures/Promises-RxJava | 219 | | |
| Futures/Promises-Node-bluebird | | 285 / 195 | |
