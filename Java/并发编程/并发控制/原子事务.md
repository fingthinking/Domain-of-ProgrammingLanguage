

# Introduction
原子即不可分割，原子操作就是中间不能停顿，一步到位。这里举一个用原子操作解决多线程下同步问题的简单例子，譬如C++中一条简单的指令：
```
i++
```
编译成汇编之后就是：
```
movl i(%rip), %eax
addl $1, %eax
movl %eax, i(%rip)
```
简单描述下上面的汇编操作：
1)读取当前变量i并把它赋值给一个临时寄存器;
2)给临时寄存器+1;
3)把eax的新值写回内存。

我们可以清楚看到C代码只需要一句，但编译成汇编却需要三步(这里不考虑编译器优化，实际上通过编译器优化可以将这三条汇编指令合并成一条)。和上述抢票 类似，导致的问题显而易见，但是解决方案也简单。按照原子操作解决同步问题方式：依靠处理器原语支持把上述三条指令合三为一，当做一条指令来执行，保证在 执行过程中不会被打断并且多线程并发也不会受到干扰。这样同步问题迎刃而解，这也就是所谓的原子操作。但事情总不会都如此简单，并且处理器没有义务为任意 代码片段提供原子性操作，尤其是我们的临界区资源十分庞大甚至大小不确定，处理器没有必要或是很难提供原子性支持。这个时候加锁机制就出现了。



