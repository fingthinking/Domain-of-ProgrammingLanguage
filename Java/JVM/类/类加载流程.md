# ClassLoading

![](http://img.blog.csdn.net/20151010184504881)

# 装载

(1).找到该类型的 class 文件，产生一个该类型的 class 文件二进制数据流(ClassLoader 需要实现的 loadClassData()方法)
　　(2).解析该二进制数据流为方法区内的数据结构
　　(3).创建一个该类型的 java.lang.Class 实例
　　在加载器的相关代码中可以看到，最终通过 defineClass()创建一个 Java 类型对象(Class 对象)。

# 连接

## 验证

class 文件校验器需要四趟独立的扫描来完成验证工作，其中：
第一趟扫描在装载时进行，会对 class 文件进行结构检查，如
　　(1).对魔数进行检查，以判断该文件是否是一个正常的 class 文件
　　(2).对主次版本号进行检查，以判断 class 文件是否与 java 虚拟机兼容
　　(3).对 class 文件的长度和类型进行检查，避免 class 文件部分缺失或被附加内容。
第二趟扫描在连接过程中进行，会对类型数据进行语义检查，主要检查各个类的二进制兼容性(主要是查看超类和子类的关系)和类本身是否符合特定的语义条件
　　(1).final 类不能拥有子类
　　(2).final 方法不能被重写(覆盖)
　　(3).子类和超类之间没有不兼容的方法声明
　　(4).检查常量池入口类型是否一致(如 CONSTANT_Class 常量池的内容是否指向一个 CONSTANT_Utf8 字符串常量池)
　　(5).检查常量池的所有特殊字符串，以确定它们是否是其所属类型的实例，以及是否符合特定的上下文无关语法、格式
第三趟扫描为字节码验证，其验证内容和实现较为复杂，主要检验字节码是否可以被 java 虚拟机安全地执行。
第四趟扫描在解析过程中进行，为对符号引用的验证。在动态连接过程中，通过保存在常量池的符号引用查找被引用的类、接口、字段、方法时，在把符号引用替换成直接引用时，首先需要确认查找的元素真正存在，然后需要检查访问权限、查找的元素是否是静态类成员而非实例成员。

## 准备

为类变量分配内存、设置默认初始值(内存设置初始值，而非对类变量真正地进行初始化，即类中声明 int i = 5，但实际上这里是分配内存并设置初始值为 0)

## 解析

在类的常量池中寻找类、接口、字段、方法的符号引用，将这些符号引用替换成直接引用
